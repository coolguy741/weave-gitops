// Code generated by counterfeiter. DO NOT EDIT.
package gitprovidersfakes

import (
	"sync"

	"github.com/weaveworks/weave-gitops/pkg/gitproviders"
)

type FakeGitProviderHandler struct {
	CreateRepositoryStub        func(string, string, bool) error
	createRepositoryMutex       sync.RWMutex
	createRepositoryArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
	}
	createRepositoryReturns struct {
		result1 error
	}
	createRepositoryReturnsOnCall map[int]struct {
		result1 error
	}
	DeployKeyExistsStub        func(string, string) (bool, error)
	deployKeyExistsMutex       sync.RWMutex
	deployKeyExistsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deployKeyExistsReturns struct {
		result1 bool
		result2 error
	}
	deployKeyExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RepositoryExistsStub        func(string, string) (bool, error)
	repositoryExistsMutex       sync.RWMutex
	repositoryExistsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	repositoryExistsReturns struct {
		result1 bool
		result2 error
	}
	repositoryExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UploadDeployKeyStub        func(string, string, []byte) error
	uploadDeployKeyMutex       sync.RWMutex
	uploadDeployKeyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []byte
	}
	uploadDeployKeyReturns struct {
		result1 error
	}
	uploadDeployKeyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGitProviderHandler) CreateRepository(arg1 string, arg2 string, arg3 bool) error {
	fake.createRepositoryMutex.Lock()
	ret, specificReturn := fake.createRepositoryReturnsOnCall[len(fake.createRepositoryArgsForCall)]
	fake.createRepositoryArgsForCall = append(fake.createRepositoryArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.CreateRepositoryStub
	fakeReturns := fake.createRepositoryReturns
	fake.recordInvocation("CreateRepository", []interface{}{arg1, arg2, arg3})
	fake.createRepositoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitProviderHandler) CreateRepositoryCallCount() int {
	fake.createRepositoryMutex.RLock()
	defer fake.createRepositoryMutex.RUnlock()
	return len(fake.createRepositoryArgsForCall)
}

func (fake *FakeGitProviderHandler) CreateRepositoryCalls(stub func(string, string, bool) error) {
	fake.createRepositoryMutex.Lock()
	defer fake.createRepositoryMutex.Unlock()
	fake.CreateRepositoryStub = stub
}

func (fake *FakeGitProviderHandler) CreateRepositoryArgsForCall(i int) (string, string, bool) {
	fake.createRepositoryMutex.RLock()
	defer fake.createRepositoryMutex.RUnlock()
	argsForCall := fake.createRepositoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGitProviderHandler) CreateRepositoryReturns(result1 error) {
	fake.createRepositoryMutex.Lock()
	defer fake.createRepositoryMutex.Unlock()
	fake.CreateRepositoryStub = nil
	fake.createRepositoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitProviderHandler) CreateRepositoryReturnsOnCall(i int, result1 error) {
	fake.createRepositoryMutex.Lock()
	defer fake.createRepositoryMutex.Unlock()
	fake.CreateRepositoryStub = nil
	if fake.createRepositoryReturnsOnCall == nil {
		fake.createRepositoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createRepositoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitProviderHandler) DeployKeyExists(arg1 string, arg2 string) (bool, error) {
	fake.deployKeyExistsMutex.Lock()
	ret, specificReturn := fake.deployKeyExistsReturnsOnCall[len(fake.deployKeyExistsArgsForCall)]
	fake.deployKeyExistsArgsForCall = append(fake.deployKeyExistsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeployKeyExistsStub
	fakeReturns := fake.deployKeyExistsReturns
	fake.recordInvocation("DeployKeyExists", []interface{}{arg1, arg2})
	fake.deployKeyExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitProviderHandler) DeployKeyExistsCallCount() int {
	fake.deployKeyExistsMutex.RLock()
	defer fake.deployKeyExistsMutex.RUnlock()
	return len(fake.deployKeyExistsArgsForCall)
}

func (fake *FakeGitProviderHandler) DeployKeyExistsCalls(stub func(string, string) (bool, error)) {
	fake.deployKeyExistsMutex.Lock()
	defer fake.deployKeyExistsMutex.Unlock()
	fake.DeployKeyExistsStub = stub
}

func (fake *FakeGitProviderHandler) DeployKeyExistsArgsForCall(i int) (string, string) {
	fake.deployKeyExistsMutex.RLock()
	defer fake.deployKeyExistsMutex.RUnlock()
	argsForCall := fake.deployKeyExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitProviderHandler) DeployKeyExistsReturns(result1 bool, result2 error) {
	fake.deployKeyExistsMutex.Lock()
	defer fake.deployKeyExistsMutex.Unlock()
	fake.DeployKeyExistsStub = nil
	fake.deployKeyExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProviderHandler) DeployKeyExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deployKeyExistsMutex.Lock()
	defer fake.deployKeyExistsMutex.Unlock()
	fake.DeployKeyExistsStub = nil
	if fake.deployKeyExistsReturnsOnCall == nil {
		fake.deployKeyExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deployKeyExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProviderHandler) RepositoryExists(arg1 string, arg2 string) (bool, error) {
	fake.repositoryExistsMutex.Lock()
	ret, specificReturn := fake.repositoryExistsReturnsOnCall[len(fake.repositoryExistsArgsForCall)]
	fake.repositoryExistsArgsForCall = append(fake.repositoryExistsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RepositoryExistsStub
	fakeReturns := fake.repositoryExistsReturns
	fake.recordInvocation("RepositoryExists", []interface{}{arg1, arg2})
	fake.repositoryExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitProviderHandler) RepositoryExistsCallCount() int {
	fake.repositoryExistsMutex.RLock()
	defer fake.repositoryExistsMutex.RUnlock()
	return len(fake.repositoryExistsArgsForCall)
}

func (fake *FakeGitProviderHandler) RepositoryExistsCalls(stub func(string, string) (bool, error)) {
	fake.repositoryExistsMutex.Lock()
	defer fake.repositoryExistsMutex.Unlock()
	fake.RepositoryExistsStub = stub
}

func (fake *FakeGitProviderHandler) RepositoryExistsArgsForCall(i int) (string, string) {
	fake.repositoryExistsMutex.RLock()
	defer fake.repositoryExistsMutex.RUnlock()
	argsForCall := fake.repositoryExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitProviderHandler) RepositoryExistsReturns(result1 bool, result2 error) {
	fake.repositoryExistsMutex.Lock()
	defer fake.repositoryExistsMutex.Unlock()
	fake.RepositoryExistsStub = nil
	fake.repositoryExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProviderHandler) RepositoryExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.repositoryExistsMutex.Lock()
	defer fake.repositoryExistsMutex.Unlock()
	fake.RepositoryExistsStub = nil
	if fake.repositoryExistsReturnsOnCall == nil {
		fake.repositoryExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.repositoryExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProviderHandler) UploadDeployKey(arg1 string, arg2 string, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.uploadDeployKeyMutex.Lock()
	ret, specificReturn := fake.uploadDeployKeyReturnsOnCall[len(fake.uploadDeployKeyArgsForCall)]
	fake.uploadDeployKeyArgsForCall = append(fake.uploadDeployKeyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.UploadDeployKeyStub
	fakeReturns := fake.uploadDeployKeyReturns
	fake.recordInvocation("UploadDeployKey", []interface{}{arg1, arg2, arg3Copy})
	fake.uploadDeployKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitProviderHandler) UploadDeployKeyCallCount() int {
	fake.uploadDeployKeyMutex.RLock()
	defer fake.uploadDeployKeyMutex.RUnlock()
	return len(fake.uploadDeployKeyArgsForCall)
}

func (fake *FakeGitProviderHandler) UploadDeployKeyCalls(stub func(string, string, []byte) error) {
	fake.uploadDeployKeyMutex.Lock()
	defer fake.uploadDeployKeyMutex.Unlock()
	fake.UploadDeployKeyStub = stub
}

func (fake *FakeGitProviderHandler) UploadDeployKeyArgsForCall(i int) (string, string, []byte) {
	fake.uploadDeployKeyMutex.RLock()
	defer fake.uploadDeployKeyMutex.RUnlock()
	argsForCall := fake.uploadDeployKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGitProviderHandler) UploadDeployKeyReturns(result1 error) {
	fake.uploadDeployKeyMutex.Lock()
	defer fake.uploadDeployKeyMutex.Unlock()
	fake.UploadDeployKeyStub = nil
	fake.uploadDeployKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitProviderHandler) UploadDeployKeyReturnsOnCall(i int, result1 error) {
	fake.uploadDeployKeyMutex.Lock()
	defer fake.uploadDeployKeyMutex.Unlock()
	fake.UploadDeployKeyStub = nil
	if fake.uploadDeployKeyReturnsOnCall == nil {
		fake.uploadDeployKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadDeployKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitProviderHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createRepositoryMutex.RLock()
	defer fake.createRepositoryMutex.RUnlock()
	fake.deployKeyExistsMutex.RLock()
	defer fake.deployKeyExistsMutex.RUnlock()
	fake.repositoryExistsMutex.RLock()
	defer fake.repositoryExistsMutex.RUnlock()
	fake.uploadDeployKeyMutex.RLock()
	defer fake.uploadDeployKeyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGitProviderHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ gitproviders.GitProviderHandler = new(FakeGitProviderHandler)
